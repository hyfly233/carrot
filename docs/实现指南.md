# Go 语言实现 Hadoop YARN 完整指南

## 项目概述

Carrot 是一个使用 Go 语言从零开始实现的 Hadoop YARN (Yet Another Resource Negotiator) 系统。

## 核心架构设计

### 1. 系统组件

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Client        │    │ ResourceManager │    │  NodeManager    │
│                 │    │                 │    │                 │
│ - 提交应用       │◄───┤ - 资源管理        │◄───┤ - 容器管理       │
│ - 监控状态       │    │ - 应用调度        │    │ - 心跳上报       │
│                 │    │ - 节点管理       │    │ - 资源监控        │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                              │
                              ▼
                       ┌──────────────────┐
                       │ ApplicationMaster│
                       │                  │
                       │ - 应用协调        │
                       │ - 容器请求        │
                       │ - 任务监控        │
                       └─────────────────┘
```

### 2. 核心特性

#### 资源管理

-   **多维度资源**: 支持内存和 CPU 核心数的资源抽象
-   **动态分配**: 实时监控和调整资源分配
-   **资源隔离**: 基于容器的资源隔离机制

#### 任务调度

-   **FIFO 调度器**: 实现先进先出调度策略
-   **扩展性设计**: 支持多种调度算法（Capacity、Fair）
-   **优先级支持**: 应用程序优先级和队列管理

#### 容器管理

-   **生命周期管理**: 完整的容器创建、运行、监控、销毁流程
-   **进程隔离**: 基于操作系统进程的隔离
-   **状态跟踪**: 实时容器状态监控和报告

## 技术实现细节

## ResourceManager 核心模块实现

### 1. ApplicationManager (应用程序管理器)

应用程序管理器是 ResourceManager 的核心组件之一，负责管理集群中所有应用程序的生命周期。

#### 功能特性

-   **应用程序生命周期管理**：完整的应用程序状态管理，从提交到完成
-   **应用程序尝试管理**：支持多次尝试机制，提高应用程序的容错性
-   **事件驱动架构**：基于事件的状态转换和处理机制
-   **清理机制**：自动清理已完成的应用程序，防止内存泄漏
-   **并发安全**：使用读写锁保证线程安全

#### 核心组件

-   `ApplicationManager`: 主要管理器类
-   `Application`: 应用程序实体
-   `ApplicationAttempt`: 应用程序尝试实体
-   `ApplicationEvent`: 应用程序事件系统

#### 主要接口

```go
func NewApplicationManager(config *ApplicationManagerConfig) *ApplicationManager
func (am *ApplicationManager) SubmitApplication(appSubmissionContext common.ApplicationSubmissionContext) (*Application, error)
func (am *ApplicationManager) GetApplications() []*Application
func (am *ApplicationManager) GetApplication(appID common.ApplicationID) (*Application, error)
func (am *ApplicationManager) Stop() error
```

#### 配置示例

```go
config := &applicationmanager.ApplicationManagerConfig{
    MaxCompletedApps:       100,
    AppCleanupInterval:     30 * time.Second,
    MaxApplicationAttempts: 3,
    EnableRecovery:         true,
}
```

### 2. NodeManager 组件

NodeManager 组件负责管理集群中的节点和资源，是资源管理的核心部分。

#### 功能特性

-   **节点生命周期管理**：节点注册、心跳监控、状态管理
-   **资源跟踪**：详细的资源分配和释放跟踪
-   **健康监控**：节点健康状态检查和故障检测
-   **容器管理**：节点上容器的状态跟踪
-   **性能指标**：详细的性能统计和监控数据

#### 核心组件

##### NodeTracker (节点跟踪器)

-   节点注册和注销
-   心跳超时检测
-   节点状态管理
-   失效节点清理

##### Node (节点实体)

-   节点基本信息管理
-   资源容量和使用情况
-   容器列表维护
-   Builder 模式构建

##### ResourceTracker (资源跟踪器)

-   资源分配和释放
-   资源使用情况统计
-   资源快照功能
-   错误处理机制

#### 主要接口

```go
func NewNodeTracker(heartbeatTimeout time.Duration) *NodeTracker
func (nt *NodeTracker) RegisterNode(nodeID common.NodeID, resource common.Resource, httpAddress string) (*Node, error)
func NewResourceTracker() *ResourceTracker
func (rt *ResourceTracker) AllocateResource(containerID common.ContainerID, resource common.Resource) error
func (rt *ResourceTracker) DeallocateResource(containerID common.ContainerID) error
```

### 3. Recovery (恢复管理器)

恢复管理器提供了集群的故障恢复能力，确保系统的高可用性。

#### 功能特性

-   **检查点机制**：定期保存集群状态快照
-   **状态恢复**：从快照恢复集群状态
-   **多种存储后端**：支持内存和文件存储
-   **恢复策略**：智能的恢复重试机制
-   **事件驱动**：恢复过程的事件通知

#### 核心组件

##### RecoveryManager (恢复管理器)

-   检查点管理
-   恢复过程控制
-   恢复状态监控
-   后台任务调度

##### StateStore (状态存储)

-   **MemoryStateStore**: 内存存储实现
-   **FileStateStore**: 文件存储实现
-   快照的保存和加载
-   快照元数据管理

##### 快照结构

-   `ClusterSnapshot`: 完整的集群状态快照
-   `ApplicationSnapshot`: 应用程序状态快照
-   `NodeSnapshot`: 节点状态快照
-   `ResourceSnapshot`: 资源状态快照

#### 主要接口

```go
func NewRecoveryManager(config *RecoveryManagerConfig) (*RecoveryManager, error)
func (rm *RecoveryManager) SaveCheckpoint(snapshot *ClusterSnapshot) error
func (rm *RecoveryManager) StartRecovery() error
func (rm *RecoveryManager) GetLatestSnapshot() (*ClusterSnapshot, error)
func (rm *RecoveryManager) GetRecoveryStatus() *RecoveryStatus
```

#### 配置示例

```go
config := &recovery.RecoveryManagerConfig{
    Enabled:             true,
    CheckpointInterval:  5 * time.Minute,
    MaxRecoveryAttempts: 3,
    StateStoreType:      "file",
    StateStoreConfig: map[string]interface{}{
        "directory": "/var/carrot/recovery",
    },
}
```

## ApplicationMaster 详细实现

### 概述

ApplicationMaster (AM) 是 YARN 架构中的核心组件，负责协调特定应用程序的执行。每个应用程序都有一个对应的 ApplicationMaster 实例。

### 架构设计

#### 核心组件

1. **ApplicationMaster** - 主控制器

    - 管理应用程序生命周期
    - 协调容器资源请求和释放
    - 监控任务执行状态
    - 提供 Web UI 和 REST API

2. **ResourceManager Client** - RM 通信客户端

    - 注册/注销 ApplicationMaster
    - 发送心跳和资源请求
    - 接收容器分配信息

3. **NodeManager Client** - NM 通信客户端

    - 启动和停止容器
    - 获取容器状态
    - 获取容器日志

4. **HTTP Server** - Web 服务器
    - 提供 REST API
    - 展示应用程序状态
    - 实时监控界面

### 应用程序类型

#### 1. 简单应用程序 (SimpleApplication)

适用于独立任务执行场景：

```go
app := applicationmaster.NewSimpleApplication(am, 3)
err := app.Run(ctx)
```

特点：

-   每个任务在独立容器中运行
-   任务之间无依赖关系
-   适合批处理作业

#### 2. 分布式应用程序 (DistributedApplication)

适用于主从架构应用：

```go
app := applicationmaster.NewDistributedApplication(am, 3)
err := app.Run(ctx)
```

特点：

-   包含一个主任务和多个工作任务
-   主任务协调工作任务执行
-   适合分布式计算框架

### 生命周期管理

```
ApplicationMaster 生命周期：

1. 启动 → 2. 注册RM → 3. 请求容器 → 4. 启动容器 → 5. 监控执行 → 6. 清理资源 → 7. 注销RM → 8. 停止
     ↑                                                                                 ↓
     └─────────────────────────────── 心跳通信 ─────────────────────────────────────────┘
```

### 容器管理

-   **容器请求**: 根据应用需求向 ResourceManager 请求容器
-   **容器分配**: 处理 ResourceManager 分配的容器
-   **容器启动**: 通过 NodeManager 启动容器
-   **容器监控**: 定期检查容器状态
-   **容器清理**: 释放不再需要的容器

### 状态监控

ApplicationMaster 维护以下状态信息：

```go
type ApplicationMaster struct {
    allocatedContainers  map[string]*common.Container  // 已分配容器
    completedContainers  map[string]*common.Container  // 已完成容器
    failedContainers     map[string]*common.Container  // 失败容器
    pendingRequests      []*common.ContainerRequest    // 待处理请求
    progress             float32                       // 执行进度
    applicationState     string                        // 应用状态
}
```

### Web UI

ApplicationMaster 提供了直观的 Web 界面：

-   **应用程序概览**: 显示基本信息和状态
-   **容器管理**: 实时显示容器分配情况
-   **资源监控**: 展示内存和 CPU 使用情况
-   **自动刷新**: 每 5 秒自动更新状态

访问地址: `http://localhost:8088`

### REST API 端点

| 端点                          | 方法 | 说明             |
| ----------------------------- | ---- | ---------------- |
| `/ws/v1/appmaster/info`       | GET  | 获取应用程序信息 |
| `/ws/v1/appmaster/status`     | GET  | 获取运行状态     |
| `/ws/v1/appmaster/containers` | GET  | 获取容器列表     |
| `/ws/v1/appmaster/progress`   | GET  | 获取执行进度     |
| `/ws/v1/appmaster/metrics`    | GET  | 获取性能指标     |
| `/ws/v1/appmaster/shutdown`   | POST | 关闭应用程序     |

### 配置参数

#### 命令行参数

```bash
./bin/applicationmaster \
    -application_id="1692969600_1" \
    -application_attempt_id="1692969600_1_1" \
    -rm_address="http://localhost:8030" \
    -app_type="simple" \
    -num_tasks=3 \
    -port=8088 \
    -heartbeat_interval=10s \
    -max_retries=3 \
    -debug=true
```

#### 参数说明

| 参数                     | 类型     | 默认值                  | 说明                 |
| ------------------------ | -------- | ----------------------- | -------------------- |
| `application_id`         | string   | 必需                    | 应用程序 ID          |
| `application_attempt_id` | string   | 必需                    | 应用程序尝试 ID      |
| `rm_address`             | string   | `http://localhost:8030` | ResourceManager 地址 |
| `app_type`               | string   | `simple`                | 应用程序类型         |
| `num_tasks`              | int      | 3                       | 简单应用任务数       |
| `num_workers`            | int      | 2                       | 分布式应用工作节点数 |
| `port`                   | int      | 8088                    | HTTP 服务端口        |
| `heartbeat_interval`     | duration | 10s                     | 心跳间隔             |
| `max_retries`            | int      | 3                       | 最大重试次数         |
| `debug`                  | bool     | false                   | 调试模式             |

### 错误处理

#### 1. 容器失败处理

```go
func (am *ApplicationMaster) handleFailedContainer(containerID common.ContainerID) {
    // 记录失败信息
    am.logger.Error("Container failed", zap.String("container_id", containerKey))

    // 移动到失败列表
    am.failedContainers[containerKey] = container

    // 根据重试策略决定是否重新请求容器
    if retryCount < am.maxContainerRetries {
        am.RequestContainers([]*common.ContainerRequest{originalRequest})
    }
}
```

#### 2. 网络异常处理

-   ResourceManager 连接失败时的重试机制
-   NodeManager 通信异常的处理
-   心跳超时的恢复策略

#### 3. 资源不足处理

-   容器请求被拒绝时的等待策略
-   资源竞争的处理机制
-   降级执行策略

### 1. 通信机制

#### HTTP REST API

```bash
// ResourceManager API 端点
GET  /ws/v1/cluster/info // 集群信息
GET  /ws/v1/cluster/apps // 应用程序列表
POST /ws/v1/cluster/apps // 提交应用程序
GET  /ws/v1/cluster/nodes // 节点列表
POST /ws/v1/cluster/apps/new-application // 获取应用程序ID
```

#### 心跳机制

```go
// NodeManager 定期向 ResourceManager 发送心跳
type HeartbeatData struct {
NodeID       common.NodeID   `json:"node_id"`
UsedResource common.Resource `json:"used_resource"`
Containers   []*Container    `json:"containers"`
}
```

### 2. 数据结构设计

#### 核心类型定义

```go
// 资源抽象
type Resource struct {
Memory int64 `json:"memory"` // MB
VCores int32 `json:"vcores"` // 虚拟核心数
}

// 容器标识
type ContainerID struct {
ApplicationAttemptID ApplicationAttemptID `json:"application_attempt_id"`
ContainerID         int64                 `json:"container_id"`
}

// 应用程序提交上下文
type ApplicationSubmissionContext struct {
ApplicationID   ApplicationID           `json:"application_id"`
ApplicationName string                  `json:"application_name"`
Resource       Resource                `json:"resource"`
AMContainerSpec ContainerLaunchContext `json:"am_container_spec"`
}
```

### 3. 调度器实现

#### 接口设计

```go
type Scheduler interface {
  Schedule(app *ApplicationInfo) ([]*common.Container, error)
  AllocateContainers(requests []common.ContainerRequest) ([]*common.Container, error)
  SetResourceManager(rm ResourceManagerInterface)
}
```

#### FIFO 调度算法

```go
func (s *FIFOScheduler) findAvailableNode(resource common.Resource) *NodeInfo {
  nodes := s.rm.GetNodesForScheduler()
  for _, node := range nodes {
    if node.State == common.NodeStateRunning &&
      node.AvailableResource.Memory >= resource.Memory &&
      node.AvailableResource.VCores >= resource.VCores {
        return node
      }
  }
  return nil
}
```

### 4. 容器执行机制

#### 容器启动流程

```go
func (nm *NodeManager) launchContainer(container *Container) error {
  // 1. 创建工作目录
  workDir := fmt.Sprintf("/tmp/yarn-containers/%s", containerKey)
  os.MkdirAll(workDir, 0755)

  // 2. 准备命令和环境
  command := container.LaunchContext.Commands[0]
  cmd := exec.Command("bash", "-c", command)
  cmd.Dir = workDir
  cmd.Env = prepareEnvironment(container.LaunchContext.Environment)

  // 3. 启动进程
  if err := cmd.Start(); err != nil {
    return err
  }

  // 4. 监控进程
  go nm.monitorContainerProcess(container, cmd)
  return nil
}
```

## 使用指南

### 1. 编译和安装

```bash
# 克隆项目
git clone <repository-url>
cd carrot

# 编译所有组件
make build

# 编译结果在 bin/ 目录下
ls bin/
# resourcemanager nodemanager client
```

### 2. 启动集群

#### 方式一：使用脚本启动

```bash
# 启动完整集群
./scripts/start-cluster.sh

# 停止集群
./scripts/stop-cluster.sh
```

#### 方式二：手动启动

```bash
# 启动 ResourceManager
./bin/resourcemanager -port 8088

# 启动 NodeManager
./bin/nodemanager -port 8042 -host localhost \
    -rm-url http://localhost:8088 -memory 8192 -vcores 8
```

### 3. 提交应用程序

```bash
# 提交简单测试应用
./bin/client -rm-url http://localhost:8088 \
    -app-name "hello-world" \
    -command "echo 'Hello YARN!'; sleep 30"

# 提交复杂应用
./bin/client -rm-url http://localhost:8088 \
    -app-name "data-processing" \
    -app-type "MapReduce" \
    -queue "production" \
    -memory 2048 \
    -vcores 2 \
    -command "python3 /path/to/data_processor.py"
```

### 4. 监控和管理

#### REST API 查询

```bash
# 查看集群信息
curl http://localhost:8088/ws/v1/cluster/info

# 查看节点状态
curl http://localhost:8088/ws/v1/cluster/nodes

# 查看应用程序
curl http://localhost:8088/ws/v1/cluster/apps

# 查看容器状态
curl http://localhost:8042/ws/v1/node/containers
```

## 扩展开发

### 1. 添加新的调度器

```go
// 实现 Scheduler 接口
type CustomScheduler struct {
rm ResourceManagerInterface
}

func (s *CustomScheduler) Schedule(app *ApplicationInfo) ([]*common.Container, error) {
// 自定义调度逻辑
return containers, nil
}

// 在 ResourceManager 中注册
func NewResourceManager() *ResourceManager {
rm := &ResourceManager{...}
customScheduler := NewCustomScheduler()
customScheduler.SetResourceManager(rm)
rm.scheduler = customScheduler
return rm
}
```

### 2. 扩展容器执行器

```go
// 自定义容器执行器
type DockerContainerExecutor struct {
// Docker 相关配置
}

func (e *DockerContainerExecutor) LaunchContainer(ctx ContainerLaunchContext) error {
// Docker 容器启动逻辑
return nil
}
```

### 3. 添加安全认证

```go
// 添加 JWT 认证中间件
func authMiddleware(next http.HandlerFunc) http.HandlerFunc {
return func(w http.ResponseWriter, r *http.Request) {
token := r.Header.Get("Authorization")
if !validateJWTToken(token) {
http.Error(w, "Unauthorized", http.StatusUnauthorized)
return
}
next(w, r)
}
}
```

## 性能优化

### 1. 资源管理优化

-   **资源预留**: 实现资源预留机制，避免资源碎片
-   **负载均衡**: 在多个节点间平均分配负载
-   **资源回收**: 及时回收已完成容器的资源

### 2. 调度优化

-   **批量调度**: 批量处理调度请求，减少调度延迟
-   **本地性调度**: 考虑数据本地性，减少网络传输
-   **优先级队列**: 实现多级队列调度

### 3. 网络优化

-   **连接池**: 使用 HTTP 连接池减少连接开销
-   **心跳优化**: 动态调整心跳间隔
-   **压缩传输**: 对大数据传输启用压缩

## 监控和诊断

### 1. 日志系统

```go
// 结构化日志
log.Printf("Container %v started on node %s:%d with resource %+v",
containerID, nodeID.Host, nodeID.Port, resource)

// 错误跟踪
log.Printf("Failed to schedule application %v: %v", appID, err)
```

### 2. 指标收集

```go
// 资源利用率指标
type ClusterMetrics struct {
TotalMemory     int64   `json:"total_memory"`
UsedMemory      int64   `json:"used_memory"`
MemoryUtilization float64 `json:"memory_utilization"`
TotalVCores     int32   `json:"total_vcores"`
UsedVCores      int32   `json:"used_vcores"`
VCoreUtilization  float64 `json:"vcore_utilization"`
}
```

### 3. 健康检查

```go
// 节点健康检查
func (nm *NodeManager) healthCheck() error {
  // 检查磁盘空间
  if diskUsage() > 0.9 {
  return fmt.Errorf("disk usage too high")
}

// 检查内存使用
if memoryUsage() > 0.95 {
  return fmt.Errorf("memory usage too high")
}

return nil
}
```

## 生产环境部署

### 1. Docker 容器化

```dockerfile
# Dockerfile.resourcemanager
FROM golang:1.21-alpine AS builder
WORKDIR /app
COPY . .
RUN go build -o resourcemanager cmd/resourcemanager/main.go

FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=builder /app/resourcemanager .
EXPOSE 8088
CMD ["./resourcemanager"]
```

### 2. Kubernetes 部署

```yaml
# resourcemanager-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
    name: yarn-resourcemanager
spec:
    replicas: 1
    selector:
        matchLabels:
            app: yarn-resourcemanager
    template:
        metadata:
            labels:
                app: yarn-resourcemanager
        spec:
            containers:
                - name: resourcemanager
                  image: carrot/resourcemanager:latest
                  ports:
                      - containerPort: 8088
                  env:
                      - name: PORT
                        value: "8088"
```

### 3. 高可用配置

```go
// ResourceManager 高可用配置
type HAConfig struct {
    EnableHA     bool   `json:"enable_ha"`
    ZKQuorum     string `json:"zk_quorum"`
    ClusterID    string `json:"cluster_id"`
    StateStore   string `json:"state_store"`
}
```

## 故障排除

### 1. 常见问题

#### 问题：NodeManager 无法注册到 ResourceManager

```bash
# 检查网络连接
curl http://resourcemanager:8088/ws/v1/cluster/info

# 检查 NodeManager 日志
tail -f logs/nodemanager.log
```

#### 问题：容器启动失败

```bash
# 检查资源是否充足
curl http://localhost:8088/ws/v1/cluster/nodes

# 检查容器日志
ls /tmp/yarn-containers/*/
```

#### 问题：应用程序长时间处于 SUBMITTED 状态

```bash
# 检查调度器状态
curl http://localhost:8088/ws/v1/cluster/apps

# 检查节点可用性
curl http://localhost:8088/ws/v1/cluster/nodes
```

### 2. 调试技巧

```go
// 启用详细日志
log.SetFlags(log.LstdFlags | log.Lshortfile)

// 添加调试信息
log.Printf("DEBUG: Processing application %v with resource %+v", appID, resource)
```

## 使用示例和最佳实践

### ApplicationMaster 使用示例

#### 1. 启动简单应用程序

```bash
# 生成应用程序 ID
APP_ID="$(date +%s)_1"
ATTEMPT_ID="${APP_ID}_1"

# 启动 ApplicationMaster
./bin/applicationmaster \
    -application_id="$APP_ID" \
    -application_attempt_id="$ATTEMPT_ID" \
    -app_type="simple" \
    -num_tasks=5 \
    -debug=true
```

#### 2. 启动分布式应用程序

```bash
# 生成应用程序 ID
APP_ID="$(date +%s)_2"
ATTEMPT_ID="${APP_ID}_1"

# 启动 ApplicationMaster
./bin/applicationmaster \
    -application_id="$APP_ID" \
    -application_attempt_id="$ATTEMPT_ID" \
    -app_type="distributed" \
    -num_workers=4 \
    -port=8089 \
    -debug=true
```

#### 3. 通过 ResourceManager 自动启动

通常情况下，ApplicationMaster 由 ResourceManager 自动启动：

```bash
# 1. 提交应用程序到 ResourceManager
curl -X POST http://localhost:8030/ws/v1/cluster/apps \
    -H "Content-Type: application/json" \
    -d '{
        "application_name": "test-app",
        "application_type": "YARN",
        "queue": "default",
        "am_container_spec": {
            "commands": ["./bin/applicationmaster", "-app_type=simple"]
        }
    }'

# 2. ResourceManager 会自动分配容器并启动 ApplicationMaster
```

### 扩展开发指南

#### 1. 自定义应用程序类型

```go
type CustomApplication struct {
    am     *ApplicationMaster
    logger *zap.Logger
    // 自定义字段
}

func (app *CustomApplication) Run(ctx context.Context) error {
    // 实现自定义应用程序逻辑
    return nil
}
```

#### 2. 自定义调度策略

```go
func (am *ApplicationMaster) customScheduleLogic() {
    // 根据应用特性实现自定义调度
    // 例如：优先级调度、位置感知调度等
}
```

#### 3. 监控扩展

```go
func (am *ApplicationMaster) registerCustomMetrics() {
    // 注册自定义性能指标
    // 集成 Prometheus 等监控系统
}
```

### 最佳实践

#### 1. 资源管理

-   合理设置容器资源大小
-   避免资源浪费和不足
-   实现动态资源调整

#### 2. 容错设计

-   实现容器失败重试机制
-   设计应用程序检查点
-   处理节点故障场景

#### 3. 性能优化

-   优化容器启动时间
-   减少网络通信开销
-   实现任务并行执行

#### 4. 监控告警

-   设置关键指标告警
-   实现日志聚合分析
-   监控资源使用趋势

## 测试覆盖和质量保证

### 集成测试

#### 模块构造测试

验证所有 ResourceManager 核心模块能够正确创建和初始化：

```go
func TestResourceManagerModulesConstruction(t *testing.T) {
    // 测试 ApplicationManager
    appManagerConfig := &applicationmanager.ApplicationManagerConfig{
        MaxCompletedApps:       100,
        AppCleanupInterval:     30 * time.Second,
        MaxApplicationAttempts: 3,
        EnableRecovery:         true,
    }
    appManager := applicationmanager.NewApplicationManager(appManagerConfig)
    assert.NotNil(t, appManager)

    // 测试 NodeTracker
    nodeTracker := nodemanager.NewNodeTracker(10 * time.Minute)
    assert.NotNil(t, nodeTracker)

    // 测试 RecoveryManager
    recoveryConfig := &recovery.RecoveryManagerConfig{
        Enabled:             true,
        CheckpointInterval:  5 * time.Minute,
        MaxRecoveryAttempts: 3,
        StateStoreType:      "memory",
    }
    recoveryManager, err := recovery.NewRecoveryManager(recoveryConfig)
    assert.NoError(t, err)
    assert.NotNil(t, recoveryManager)
}
```

#### 快照功能测试

验证恢复模块的快照保存和加载功能：

```go
func TestRecoverySnapshot(t *testing.T) {
    config := &recovery.RecoveryManagerConfig{
        Enabled:             true,
        StateStoreType:      "memory",
        CheckpointInterval:  1 * time.Minute,
        MaxRecoveryAttempts: 3,
    }

    rm, err := recovery.NewRecoveryManager(config)
    assert.NoError(t, err)

    // 创建测试快照
    snapshot := &recovery.ClusterSnapshot{
        Timestamp: time.Now(),
        Applications: map[string]*recovery.ApplicationSnapshot{
            "app_1": {
                ApplicationID: "app_1",
                State:        "RUNNING",
                StartTime:    time.Now(),
            },
        },
    }

    // 保存快照
    err = rm.SaveCheckpoint(snapshot)
    assert.NoError(t, err)

    // 加载快照
    loadedSnapshot, err := rm.GetLatestSnapshot()
    assert.NoError(t, err)
    assert.Equal(t, snapshot.Applications["app_1"].ApplicationID,
                 loadedSnapshot.Applications["app_1"].ApplicationID)
}
```

### 测试结果

```bash
=== RUN   TestResourceManagerModulesConstruction
--- PASS: TestResourceManagerModulesConstruction (0.00s)
=== RUN   TestRecoverySnapshot
--- PASS: TestRecoverySnapshot (0.00s)
PASS
ok      carrot/internal/resourcemanager 0.283s
```

## 架构设计原则

### 模块间交互

```
ResourceManager
├── ApplicationManager
│   ├── Application
│   └── ApplicationAttempt
├── NodeManager Components
│   ├── NodeTracker
│   ├── Node
│   └── ResourceTracker
└── Recovery
    ├── RecoveryManager
    └── StateStore
```

### 设计原则

1. **模块化设计**: 每个模块职责明确，耦合度低
2. **并发安全**: 使用适当的同步机制保证线程安全
3. **错误处理**: 完善的错误处理和恢复机制
4. **可扩展性**: 支持配置和插件化扩展
5. **可观测性**: 完整的日志记录和性能指标

### 技术特点

#### 1. 高可用性

-   检查点和恢复机制确保系统故障后能快速恢复
-   节点故障检测和自动清理
-   应用程序重试机制

#### 2. 可扩展性

-   支持大量节点和应用程序
-   模块化设计便于功能扩展
-   配置驱动的行为控制

#### 3. 性能优化

-   高效的数据结构和算法
-   批量操作和异步处理
-   内存和 CPU 使用优化

#### 4. 监控和调试

-   详细的日志记录
-   性能指标收集
-   状态查询接口

## 故障排查和调试

### ApplicationMaster 故障排查

#### 常见问题

1. **ApplicationMaster 启动失败**

    - 检查应用程序 ID 格式
    - 验证 ResourceManager 连接
    - 查看启动日志错误信息

2. **容器分配失败**

    - 检查集群资源是否充足
    - 验证资源请求是否合理
    - 查看调度器日志

3. **容器启动失败**

    - 检查 NodeManager 状态
    - 验证容器启动命令
    - 查看容器日志

4. **性能问题**
    - 分析资源使用情况
    - 检查网络延迟
    - 优化任务并行度

#### 调试工具

-   使用 `-debug=true` 启用详细日志
-   通过 Web UI 监控实时状态
-   使用 API 获取详细信息
-   查看 ResourceManager 和 NodeManager 日志

### 监控和诊断

#### 1. ApplicationMaster 日志监控

ApplicationMaster 使用结构化日志记录重要事件：

```go
logger.Info("Container allocated",
    zap.String("container_id", containerKey),
    zap.String("node", nodeHost),
    zap.Int64("memory", resource.Memory),
    zap.Int32("vcores", resource.VCores))
```

#### 2. 性能指标

通过 `/ws/v1/appmaster/metrics` 端点获取性能指标：

-   容器分配统计
-   内存和 CPU 使用情况
-   应用程序执行进度
-   错误和重试次数

#### 3. Web UI 监控

Web UI 提供实时监控界面：

-   自动刷新状态信息
-   容器状态可视化
-   资源使用图表
-   日志查看功能
