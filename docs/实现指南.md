# Go 语言实现 Hadoop YARN 完整指南

## 项目概述

Carrot 是一个使用 Go 语言从零开始实现的 Hadoop YARN (Yet Another Resource Negotiator) 系统。

## 核心架构设计

### 1. 系统组件

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Client        │    │ ResourceManager │    │  NodeManager    │
│                 │    │                 │    │                 │
│ - 提交应用       │◄───┤ - 资源管理        │◄───┤ - 容器管理       │
│ - 监控状态       │    │ - 应用调度        │    │ - 心跳上报       │
│                 │    │ - 节点管理       │    │ - 资源监控        │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                              │
                              ▼
                       ┌──────────────────┐
                       │ ApplicationMaster│
                       │                  │
                       │ - 应用协调        │
                       │ - 容器请求        │
                       │ - 任务监控        │
                       └─────────────────┘
```

### 2. 核心特性

#### 资源管理

- **多维度资源**: 支持内存和 CPU 核心数的资源抽象
- **动态分配**: 实时监控和调整资源分配
- **资源隔离**: 基于容器的资源隔离机制

#### 任务调度

- **FIFO 调度器**: 实现先进先出调度策略
- **扩展性设计**: 支持多种调度算法（Capacity、Fair）
- **优先级支持**: 应用程序优先级和队列管理

#### 容器管理

- **生命周期管理**: 完整的容器创建、运行、监控、销毁流程
- **进程隔离**: 基于操作系统进程的隔离
- **状态跟踪**: 实时容器状态监控和报告

## 技术实现细节

### 1. 通信机制

#### HTTP REST API

```bash
// ResourceManager API 端点
GET  /ws/v1/cluster/info // 集群信息
GET  /ws/v1/cluster/apps // 应用程序列表
POST /ws/v1/cluster/apps // 提交应用程序
GET  /ws/v1/cluster/nodes // 节点列表
POST /ws/v1/cluster/apps/new-application // 获取应用程序ID
```

#### 心跳机制

```go
// NodeManager 定期向 ResourceManager 发送心跳
type HeartbeatData struct {
NodeID       common.NodeID   `json:"node_id"`
UsedResource common.Resource `json:"used_resource"`
Containers   []*Container    `json:"containers"`
}
```

### 2. 数据结构设计

#### 核心类型定义

```go
// 资源抽象
type Resource struct {
Memory int64 `json:"memory"` // MB
VCores int32 `json:"vcores"` // 虚拟核心数
}

// 容器标识
type ContainerID struct {
ApplicationAttemptID ApplicationAttemptID `json:"application_attempt_id"`
ContainerID         int64                 `json:"container_id"`
}

// 应用程序提交上下文
type ApplicationSubmissionContext struct {
ApplicationID   ApplicationID           `json:"application_id"`
ApplicationName string                  `json:"application_name"`
Resource       Resource                `json:"resource"`
AMContainerSpec ContainerLaunchContext `json:"am_container_spec"`
}
```

### 3. 调度器实现

#### 接口设计

```go
type Scheduler interface {
Schedule(app *ApplicationInfo) ([]*common.Container, error)
AllocateContainers(requests []common.ContainerRequest) ([]*common.Container, error)
SetResourceManager(rm ResourceManagerInterface)
}
```

#### FIFO 调度算法

```go
func (s *FIFOScheduler) findAvailableNode(resource common.Resource) *NodeInfo {
nodes := s.rm.GetNodesForScheduler()
for _, node := range nodes {
if node.State == common.NodeStateRunning &&
node.AvailableResource.Memory >= resource.Memory &&
node.AvailableResource.VCores >= resource.VCores {
return node
}
}
return nil
}
```

### 4. 容器执行机制

#### 容器启动流程

```go
func (nm *NodeManager) launchContainer(container *Container) error {
// 1. 创建工作目录
workDir := fmt.Sprintf("/tmp/yarn-containers/%s", containerKey)
os.MkdirAll(workDir, 0755)

// 2. 准备命令和环境
command := container.LaunchContext.Commands[0]
cmd := exec.Command("bash", "-c", command)
cmd.Dir = workDir
cmd.Env = prepareEnvironment(container.LaunchContext.Environment)

// 3. 启动进程
if err := cmd.Start(); err != nil {
return err
}

// 4. 监控进程
go nm.monitorContainerProcess(container, cmd)

return nil
}
```

## 使用指南

### 1. 编译和安装

```bash
# 克隆项目
git clone <repository-url>
cd carrot

# 编译所有组件
make build

# 编译结果在 bin/ 目录下
ls bin/
# resourcemanager nodemanager client
```

### 2. 启动集群

#### 方式一：使用脚本启动

```bash
# 启动完整集群
./scripts/start-cluster.sh

# 停止集群
./scripts/stop-cluster.sh
```

#### 方式二：手动启动

```bash
# 启动 ResourceManager
./bin/resourcemanager -port 8088

# 启动 NodeManager
./bin/nodemanager -port 8042 -host localhost \
    -rm-url http://localhost:8088 -memory 8192 -vcores 8
```

### 3. 提交应用程序

```bash
# 提交简单测试应用
./bin/client -rm-url http://localhost:8088 \
    -app-name "hello-world" \
    -command "echo 'Hello YARN!'; sleep 30"

# 提交复杂应用
./bin/client -rm-url http://localhost:8088 \
    -app-name "data-processing" \
    -app-type "MapReduce" \
    -queue "production" \
    -memory 2048 \
    -vcores 2 \
    -command "python3 /path/to/data_processor.py"
```

### 4. 监控和管理

#### REST API 查询

```bash
# 查看集群信息
curl http://localhost:8088/ws/v1/cluster/info

# 查看节点状态
curl http://localhost:8088/ws/v1/cluster/nodes

# 查看应用程序
curl http://localhost:8088/ws/v1/cluster/apps

# 查看容器状态
curl http://localhost:8042/ws/v1/node/containers
```

## 扩展开发

### 1. 添加新的调度器

```go
// 实现 Scheduler 接口
type CustomScheduler struct {
rm ResourceManagerInterface
}

func (s *CustomScheduler) Schedule(app *ApplicationInfo) ([]*common.Container, error) {
// 自定义调度逻辑
return containers, nil
}

// 在 ResourceManager 中注册
func NewResourceManager() *ResourceManager {
rm := &ResourceManager{...}
customScheduler := NewCustomScheduler()
customScheduler.SetResourceManager(rm)
rm.scheduler = customScheduler
return rm
}
```

### 2. 扩展容器执行器

```go
// 自定义容器执行器
type DockerContainerExecutor struct {
// Docker 相关配置
}

func (e *DockerContainerExecutor) LaunchContainer(ctx ContainerLaunchContext) error {
// Docker 容器启动逻辑
return nil
}
```

### 3. 添加安全认证

```go
// 添加 JWT 认证中间件
func authMiddleware(next http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        token := r.Header.Get("Authorization")
        if !validateJWTToken(token) {
            http.Error(w, "Unauthorized", http.StatusUnauthorized)
            return
        }
        next(w, r)
    }
}
```

## 性能优化

### 1. 资源管理优化

- **资源预留**: 实现资源预留机制，避免资源碎片
- **负载均衡**: 在多个节点间平均分配负载
- **资源回收**: 及时回收已完成容器的资源

### 2. 调度优化

- **批量调度**: 批量处理调度请求，减少调度延迟
- **本地性调度**: 考虑数据本地性，减少网络传输
- **优先级队列**: 实现多级队列调度

### 3. 网络优化

- **连接池**: 使用 HTTP 连接池减少连接开销
- **心跳优化**: 动态调整心跳间隔
- **压缩传输**: 对大数据传输启用压缩

## 监控和诊断

### 1. 日志系统

```go
// 结构化日志
log.Printf("Container %v started on node %s:%d with resource %+v", 
    containerID, nodeID.Host, nodeID.Port, resource)

// 错误跟踪
log.Printf("Failed to schedule application %v: %v", appID, err)
```

### 2. 指标收集

```go
// 资源利用率指标
type ClusterMetrics struct {
    TotalMemory     int64   `json:"total_memory"`
    UsedMemory      int64   `json:"used_memory"`
    MemoryUtilization float64 `json:"memory_utilization"`
    TotalVCores     int32   `json:"total_vcores"`
    UsedVCores      int32   `json:"used_vcores"`
    VCoreUtilization  float64 `json:"vcore_utilization"`
}
```

### 3. 健康检查

```go
// 节点健康检查
func (nm *NodeManager) healthCheck() error {
    // 检查磁盘空间
    if diskUsage() > 0.9 {
        return fmt.Errorf("disk usage too high")
    }
    
    // 检查内存使用
    if memoryUsage() > 0.95 {
        return fmt.Errorf("memory usage too high")
    }
    
    return nil
}
```
