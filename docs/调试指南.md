# Carrot YARN 项目调试指南

## 目录

1. [开发环境调试](#开发环境调试)
2. [使用 Delve 调试器](#使用-delve-调试器)
3. [日志调试](#日志调试)
4. [单元测试调试](#单元测试调试)
5. [集成测试调试](#集成测试调试)
6. [性能调试](#性能调试)
7. [网络调试](#网络调试)
8. [常见问题排查](#常见问题排查)

## 开发环境调试

### 1. IDE 调试配置

#### VS Code 配置

创建 `.vscode/launch.json` 配置文件：

```json
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Debug ResourceManager",
            "type": "go",
            "request": "launch",
            "mode": "auto",
            "program": "${workspaceFolder}/cmd/resourcemanager/main.go",
            "args": ["-port", "8088"],
            "env": {
                "LOG_LEVEL": "DEBUG"
            },
            "console": "integratedTerminal"
        },
        {
            "name": "Debug NodeManager",
            "type": "go",
            "request": "launch",
            "mode": "auto",
            "program": "${workspaceFolder}/cmd/nodemanager/main.go",
            "args": [
                "-port", "8042",
                "-host", "localhost",
                "-rm-url", "http://localhost:8088",
                "-memory", "4096",
                "-vcores", "4"
            ],
            "env": {
                "LOG_LEVEL": "DEBUG"
            },
            "console": "integratedTerminal"
        },
        {
            "name": "Debug Client",
            "type": "go",
            "request": "launch",
            "mode": "auto",
            "program": "${workspaceFolder}/cmd/client/main.go",
            "args": [
                "-rm-url", "http://localhost:8088",
                "-app-name", "debug-test",
                "-command", "echo 'Debug test'"
            ],
            "console": "integratedTerminal"
        },
        {
            "name": "Attach to Process",
            "type": "go",
            "request": "attach",
            "mode": "local",
            "processId": 0
        }
    ]
}
```

### GoLand/IntelliJ 配置

1. 右键点击 `main.go` 文件
2. 选择 "Debug 'go build main.go'"
3. 在 Run Configuration 中设置参数和环境变量

### 2. 命令行调试

#### 使用 Delve 调试器

安装 Delve：

```bash
go install github.com/go-delve/delve/cmd/dlv@latest
```

调试 ResourceManager：

```bash
# 编译并启动调试器
dlv debug cmd/resourcemanager/main.go -- -port 8088

# 在调试器中设置断点
(dlv) break main.main
(dlv) break internal/resourcemanager.(*ResourceManager).Start
(dlv) continue
```

调试 NodeManager：

```bash
dlv debug cmd/nodemanager/main.go -- -port 8042 -host localhost -rm-url http://localhost:8088
```

#### 远程调试

启动带调试监听的服务：

```bash
# ResourceManager 远程调试
dlv --listen=:2345 --headless=true --api-version=2 debug cmd/resourcemanager/main.go -- -port 8088

# 连接到远程调试会话
dlv connect :2345
```

## 日志调试

### 1. 增强日志配置

更新日志格式以包含更多调试信息：

```go
// 在 main.go 中添加
import (
    "log"
    "os"
)

func init() {
    // 设置日志格式
    log.SetFlags(log.LstdFlags | log.Lshortfile | log.Lmicroseconds)
    
    // 根据环境变量设置日志级别
    if os.Getenv("LOG_LEVEL") == "DEBUG" {
        log.SetOutput(os.Stdout)
    }
}
```

### 2. 结构化日志

添加结构化日志支持：

```go
type Logger struct {
    level string
}

func (l *Logger) Debug(format string, args ...interface{}) {
    if l.level == "DEBUG" {
        log.Printf("[DEBUG] "+format, args...)
    }
}

func (l *Logger) Info(format string, args ...interface{}) {
    log.Printf("[INFO] "+format, args...)
}

func (l *Logger) Error(format string, args ...interface{}) {
    log.Printf("[ERROR] "+format, args...)
}
```

### 3. 分组件日志

为不同组件创建独立的日志文件：

```bash
# 启动时重定向日志
./bin/resourcemanager -port 8088 > logs/rm-$(date +%Y%m%d-%H%M%S).log 2>&1 &
./bin/nodemanager -port 8042 > logs/nm-$(date +%Y%m%d-%H%M%S).log 2>&1 &
```

## 单元测试调试

### 1. 创建测试文件

创建组件测试：

```go
// internal/resourcemanager/resource_manager_test.go
package resourcemanager

import (
    "testing"
    "time"
    "carrot/internal/common"
)

func TestResourceManagerCreation(t *testing.T) {
    rm := NewResourceManager()
    if rm == nil {
        t.Fatal("Failed to create ResourceManager")
    }
    
    if rm.clusterTimestamp == 0 {
        t.Error("Cluster timestamp not set")
    }
}

func TestNodeRegistration(t *testing.T) {
    rm := NewResourceManager()
    
    nodeID := common.NodeID{
        Host: "test-host",
        Port: 8042,
    }
    
    resource := common.Resource{
        Memory: 4096,
        VCores: 4,
    }
    
    err := rm.RegisterNode(nodeID, resource, "http://test-host:8042")
    if err != nil {
        t.Fatalf("Failed to register node: %v", err)
    }
    
    nodes := rm.GetNodes()
    if len(nodes) != 1 {
        t.Errorf("Expected 1 node, got %d", len(nodes))
    }
}
```

运行特定测试并显示详细输出：

```bash
# 运行单个测试
go test -v ./internal/resourcemanager -run TestResourceManagerCreation

# 运行所有测试
go test -v ./...

# 运行测试并显示覆盖率
go test -v -cover ./...

# 生成覆盖率报告
go test -coverprofile=out/coverage.out ./...
go tool cover -html=out/coverage.out -o out/coverage.html
```

### 2. 基准测试

添加性能基准测试：

```go
func BenchmarkResourceManagerScheduling(b *testing.B) {
    rm := NewResourceManager()
    
    // 注册测试节点
    nodeID := common.NodeID{Host: "bench-host", Port: 8042}
    resource := common.Resource{Memory: 8192, VCores: 8}
    rm.RegisterNode(nodeID, resource, "http://bench-host:8042")
    
    b.ResetTimer()
    
    for i := 0; i < b.N; i++ {
        appID := common.ApplicationID{
            ClusterTimestamp: time.Now().Unix(),
            ID: int32(i),
        }
        
        ctx := common.ApplicationSubmissionContext{
            ApplicationID: appID,
            ApplicationName: fmt.Sprintf("bench-app-%d", i),
            Resource: common.Resource{Memory: 1024, VCores: 1},
        }
        
        _, err := rm.SubmitApplication(ctx)
        if err != nil {
            b.Fatal(err)
        }
    }
}
```

运行基准测试：

```bash
go test -bench=. -benchmem ./internal/resourcemanager
```

## 集成测试调试

### 1. 详细的集成测试

创建更详细的集成测试脚本：

```bash
#!/bin/bash
# scripts/debug-integration-test.sh

set -e  # 遇到错误立即退出

DEBUG_DIR="/tmp/carrot-debug-$(date +%Y%m%d-%H%M%S)"
mkdir -p $DEBUG_DIR/logs

echo "=== 调试集成测试 ==="
echo "调试目录: $DEBUG_DIR"

# 启用详细日志
export LOG_LEVEL=DEBUG

# 启动 ResourceManager
echo "启动 ResourceManager..."
./bin/resourcemanager -port 8088 > $DEBUG_DIR/logs/rm.log 2>&1 &
RM_PID=$!
echo "ResourceManager PID: $RM_PID"
echo $RM_PID > $DEBUG_DIR/rm.pid

# 等待服务启动
sleep 3

# 检查 ResourceManager 状态
echo "检查 ResourceManager 状态..."
if curl -f -s http://localhost:8088/ws/v1/cluster/info > $DEBUG_DIR/cluster-info.json; then
    echo "✓ ResourceManager 响应正常"
    cat $DEBUG_DIR/cluster-info.json | python3 -m json.tool 2>/dev/null || cat $DEBUG_DIR/cluster-info.json
else
    echo "✗ ResourceManager 无响应"
    echo "ResourceManager 日志:"
    cat $DEBUG_DIR/logs/rm.log
    exit 1
fi

# 启动 NodeManager
echo "启动 NodeManager..."
./bin/nodemanager -port 8042 -host localhost -rm-url http://localhost:8088 -memory 4096 -vcores 4 > $DEBUG_DIR/logs/nm.log 2>&1 &
NM_PID=$!
echo "NodeManager PID: $NM_PID"
echo $NM_PID > $DEBUG_DIR/nm.pid

# 等待节点注册
sleep 5

# 检查节点注册状态
echo "检查节点注册状态..."
curl -s http://localhost:8088/ws/v1/cluster/nodes > $DEBUG_DIR/nodes.json
NODE_COUNT=$(cat $DEBUG_DIR/nodes.json | python3 -c "import json, sys; data=json.load(sys.stdin); print(len(data.get('nodes', {}).get('node', [])))" 2>/dev/null || echo "0")

if [ "$NODE_COUNT" -gt "0" ]; then
    echo "✓ 节点注册成功，节点数量: $NODE_COUNT"
    cat $DEBUG_DIR/nodes.json | python3 -m json.tool 2>/dev/null || cat $DEBUG_DIR/nodes.json
else
    echo "✗ 节点注册失败"
    echo "NodeManager 日志:"
    cat $DEBUG_DIR/logs/nm.log
fi

# 提交测试应用
echo "提交测试应用..."
./bin/client -rm-url http://localhost:8088 -app-name "debug-test-$(date +%s)" -command "echo 'Debug test running'; sleep 5; echo 'Debug test completed'" > $DEBUG_DIR/client.log 2>&1

# 检查应用状态
sleep 2
curl -s http://localhost:8088/ws/v1/cluster/apps > $DEBUG_DIR/apps.json
echo "应用状态:"
cat $DEBUG_DIR/apps.json | python3 -m json.tool 2>/dev/null || cat $DEBUG_DIR/apps.json

echo ""
echo "=== 调试信息保存位置 ==="
echo "调试目录: $DEBUG_DIR"
echo "ResourceManager 日志: $DEBUG_DIR/logs/rm.log"
echo "NodeManager 日志: $DEBUG_DIR/logs/nm.log"
echo "集群信息: $DEBUG_DIR/cluster-info.json"
echo "节点信息: $DEBUG_DIR/nodes.json"
echo "应用信息: $DEBUG_DIR/apps.json"

echo ""
echo "进程仍在运行，可以继续调试..."
echo "ResourceManager PID: $RM_PID"
echo "NodeManager PID: $NM_PID"
echo ""
echo "要停止服务，运行:"
echo "kill $RM_PID $NM_PID"
```

### 2. 网络调试

使用 tcpdump 或 wireshark 抓包分析：

```bash
# 抓取本地 8088 端口的包
sudo tcpdump -i lo -w debug-rm.pcap port 8088

# 抓取本地 8042 端口的包
sudo tcpdump -i lo -w debug-nm.pcap port 8042
```

使用 curl 详细调试 HTTP 请求：

```bash
# 详细显示请求和响应
curl -v http://localhost:8088/ws/v1/cluster/info

# 显示响应头
curl -I http://localhost:8088/ws/v1/cluster/nodes

# 测试 POST 请求
curl -v -X POST -H "Content-Type: application/json" \
     -d '{"test": "data"}' \
     http://localhost:8088/ws/v1/cluster/apps/new-application
```

## 性能调试

### 1. CPU 性能分析

在代码中添加 pprof 支持：

```go
// 在 main.go 中添加
import (
    _ "net/http/pprof"
    "net/http"
)

func main() {
    // 启动 pprof 服务器
    go func() {
        log.Println(http.ListenAndServe("localhost:6060", nil))
    }()
    
    // 原有的主要逻辑
    // ...
}
```

生成 CPU profile：

```bash
# 运行程序一段时间后
go tool pprof http://localhost:6060/debug/pprof/profile?seconds=30

# 在 pprof 交互模式中
(pprof) top10
(pprof) web
(pprof) list function_name
```

### 2. 内存分析

```bash
# 内存使用分析
go tool pprof http://localhost:6060/debug/pprof/heap

# 查看内存分配
go tool pprof http://localhost:6060/debug/pprof/allocs
```

### 3. Goroutine 分析

```bash
# 查看 goroutine 信息
curl http://localhost:6060/debug/pprof/goroutine?debug=1

# 或使用 pprof
go tool pprof http://localhost:6060/debug/pprof/goroutine
```

## 常见问题排查

### 1. 端口占用问题

```bash
# 检查端口占用
lsof -i :8088
lsof -i :8042

# 杀死占用端口的进程
sudo kill -9 $(lsof -ti:8088)
```

### 2. 权限问题

```bash
# 检查目录权限
ls -la /tmp/yarn-containers/

# 创建必要目录
mkdir -p /tmp/yarn-containers
chmod 755 /tmp/yarn-containers
```

### 3. 网络连接问题

```bash
# 检查网络连通性
telnet localhost 8088
nc -zv localhost 8088

# 检查防火墙
sudo iptables -L
```

### 4. 日志分析

```bash
# 实时查看日志
tail -f logs/*.log

# 搜索错误日志
grep -i error logs/*.log
grep -i "failed\|error\|panic" logs/*.log

# 按时间排序查看日志
ls -lt logs/ | head -10
```

## 高级调试技巧

### 1. 使用 strace 跟踪系统调用

```bash
# 跟踪程序的系统调用
strace -o rm-strace.log ./bin/resourcemanager -port 8088

# 跟踪特定的系统调用
strace -e trace=network ./bin/resourcemanager -port 8088
```
