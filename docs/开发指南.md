# Carrot YARN 开发指南

本指南为 Carrot 项目的开发者提供完整的开发环境搭建、代码规范、测试和调试方法。

## 🛠️ 开发环境搭建

### 基础要求

```bash
# Go 版本要求
go version  # 需要 Go 1.24+

# 必需的工具
go install golang.org/x/tools/cmd/goimports@latest
go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest
go install github.com/go-delve/delve/cmd/dlv@latest

# 可选工具 (推荐)
go install github.com/air-verse/air@latest  # 热重载
go install github.com/swaggo/swag/cmd/swag@latest  # API 文档生成
```

### IDE 配置

#### VS Code 配置

创建 `.vscode/launch.json`:

```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Debug ResourceManager",
      "type": "go",
      "request": "launch",
      "mode": "auto",
      "program": "${workspaceFolder}/cmd/resourcemanager/main.go",
      "args": [
        "--config",
        "${workspaceFolder}/configs/resourcemanager.yaml",
        "--log-level",
        "debug"
      ],
      "env": {
        "CARROT_DEBUG": "true"
      },
      "console": "integratedTerminal"
    },
    {
      "name": "Debug NodeManager",
      "type": "go",
      "request": "launch",
      "mode": "auto",
      "program": "${workspaceFolder}/cmd/rmnm/main.go",
      "args": [
        "--config",
        "${workspaceFolder}/configs/rmnm.yaml",
        "--rm-url",
        "http://localhost:8088"
      ],
      "env": {
        "CARROT_DEBUG": "true"
      },
      "console": "integratedTerminal"
    },
    {
      "name": "Debug ApplicationMaster",
      "type": "go",
      "request": "launch",
      "mode": "auto",
      "program": "${workspaceFolder}/cmd/applicationmaster/main.go",
      "args": [
        "--rm-url",
        "http://localhost:8088",
        "--app-name",
        "test-app"
      ],
      "console": "integratedTerminal"
    },
    {
      "name": "Debug Test",
      "type": "go",
      "request": "launch",
      "mode": "test",
      "program": "${workspaceFolder}",
      "args": [
        "-test.v"
      ]
    }
  ]
}
```

创建 `.vscode/settings.json`:

```json
{
    "go.useLanguageServer": true,
    "go.formatTool": "goimports",
    "go.lintTool": "golangci-lint",
    "go.testFlags": ["-v"],
    "go.testTimeout": "30s",
    "go.coverOnSave": true,
    "go.coverageDecorator": {
        "type": "gutter",
        "coveredHighlightColor": "rgba(64,128,128,0.5)",
        "uncoveredHighlightColor": "rgba(128,64,64,0.25)",
        "coveredGutterStyle": "blockblue",
        "uncoveredGutterStyle": "blockred"
    },
    "files.exclude": {
        "**/.git": true,
        "**/bin": true,
        "**/vendor": true
    }
}
```

#### GoLand/IntelliJ 配置

```xml
<!-- .idea/runConfigurations/ResourceManager.xml -->
<component name="ProjectRunConfigurationManager">
    <configuration default="false" name="ResourceManager" type="GoApplicationRunConfiguration"
                   factoryName="Go Application">
        <module name="carrot"/>
        <working_directory value="$PROJECT_DIR$"/>
        <kind value="FILE"/>
        <filePath value="$PROJECT_DIR$/cmd/resourcemanager/main.go"/>
        <parameters value="--config configs/resourcemanager.yaml --log-level debug"/>
        <envs>
            <env name="CARROT_DEBUG" value="true"/>
        </envs>
        <method v="2"/>
    </configuration>
</component>
```

### 项目结构

```
carrot/
├── cmd/                    # 主程序入口
│   ├── resourcemanager/
│   ├── nodemanager/
│   ├── applicationmaster/
│   └── client/
├── internal/               # 内部包
│   ├── common/            # 公共代码
│   ├── resourcemanager/   # RM 实现
│   ├── nodemanager/       # NM 实现
│   └── applicationmaster/ # AM 实现
├── configs/               # 配置文件
├── deployments/           # 部署配置
│   ├── docker/
│   └── k8s/
├── docs/                  # 文档
├── scripts/               # 脚本
├── tests/                 # 测试
│   ├── integration/
│   └── e2e/
├── tools/                 # 工具
├── .github/               # GitHub 配置
├── Makefile
├── go.mod
└── go.sum
```

## 📋 代码规范

### Go 编码规范

#### 1. 包命名

```go
// ✅ 好的包名
package resourcemanager
package scheduler
package common

// ❌ 避免的包名
package rm_server
package ResourceManager
package utils
```

#### 2. 接口设计

```go
// ✅ 接口名以 -er 结尾
type Scheduler interface {
    Schedule(requests []*ResourceRequest) []*Allocation
}

type ResourceTracker interface {
    AllocateResource(containerID ContainerID, resource Resource) error
    ReleaseResource(containerID ContainerID) error
}

// ✅ 小接口原则
type Reader interface {
    Read([]byte) (int, error)
}

type Writer interface {
    Write([]byte) (int, error)
}

// ❌ 避免大接口
type HugeInterface interface {
    Method1()
    Method2()
    // ... 10+ methods
}
```

#### 3. 错误处理

```go
// ✅ 自定义错误类型
type InsufficientResourceError struct {
    Requested Resource
    Available Resource
}

func (e *InsufficientResourceError) Error() string {
    return fmt.Sprintf("insufficient resources: requested %v, available %v",
        e.Requested, e.Available)
}

// ✅ 错误包装
func (rm *ResourceManager) AllocateResource(req *ResourceRequest) error {
    if err := rm.validateRequest(req); err != nil {
        return fmt.Errorf("failed to validate request: %w", err)
    }

    if err := rm.scheduler.Allocate(req); err != nil {
        return fmt.Errorf("scheduler allocation failed: %w", err)
    }

    return nil
}

// ✅ 哨兵错误
var (
    ErrApplicationNotFound = errors.New("应用未找到")
    ErrNodeOffline         = errors.New("node is offline")
)
```

#### 4. 结构体设计

```go
// ✅ 字段分组和注释
type ResourceManager struct {
    // 核心组件
    applicationManager *applicationmanager.ApplicationManager
    nodeManager        *nodemanager.NodeManager
    scheduler          scheduler.Scheduler

    // 配置和状态
    config *Config
    state  *State

    // 同步原语
    mu     sync.RWMutex

    // 通道和控制
    stopCh chan struct{}
    doneCh chan struct{}

    // 日志和监控
    logger  *zap.Logger
    metrics *Metrics
}

// ✅ 构造函数模式
func NewResourceManager(config *Config) *ResourceManager {
    rm := &ResourceManager{
        config: config,
        stopCh: make(chan struct{}),
        doneCh: make(chan struct{}),
        logger: zap.NewNop(),
    }

    // 初始化组件
    rm.applicationManager = applicationmanager.New(config.ApplicationManager)
    rm.nodeManager = nodemanager.New(config.NodeManager)

    return rm
}
```

#### 5. 并发安全

```go
// ✅ 读写锁使用
type SafeCounter struct {
    mu    sync.RWMutex
    value int64
}

func (c *SafeCounter) Get() int64 {
    c.mu.RLock()
    defer c.mu.RUnlock()
    return c.value
}

func (c *SafeCounter) Inc() {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.value++
}

// ✅ Context 传递
func (rm *ResourceManager) ProcessRequest(ctx context.Context, req *Request) error {
    select {
    case <-ctx.Done():
        return ctx.Err()
    default:
        return rm.doProcess(ctx, req)
    }
}
```

### 注释规范

```go
// Package resourcemanager 实现 YARN ResourceManager 的核心功能。
//
// ResourceManager 负责管理集群资源，调度应用程序，
// 以及监控 NodeManager 的状态。主要组件包括：
//   - ApplicationManager: 管理应用程序生命周期
//   - NodeManager: 管理节点注册和心跳
//   - Scheduler: 实现资源调度算法
//
// 使用示例：
//   config := &Config{Port: 8088}
//   rm := NewResourceManager(config)
//   if err := rm.Start(); err != nil {
//       log.Fatal(err)
//   }
package resourcemanager

// ResourceManager 表示 YARN 资源管理器的主要实现。
//
// 它协调集群中的所有资源分配和应用程序调度。
// ResourceManager 是无状态的，支持高可用部署。
type ResourceManager struct {
	// 私有字段不需要注释，除非有特殊说明
}

// NewResourceManager 创建一个新的 ResourceManager 实例。
//
// 参数:
//   config - ResourceManager 配置，不能为 nil
//
// 返回:
//   *ResourceManager - 新创建的实例
//
// 如果配置无效，此函数会 panic。
func NewResourceManager(config *Config) *ResourceManager {
	// 实现...
}

// Start 启动 ResourceManager 服务。
//
// 这个方法会：
//   1. 初始化所有子组件
//   2. 启动 HTTP 服务器
//   3. 开始处理心跳和请求
//
// 返回的 error 表示启动过程中的任何失败。
// 如果启动成功，该方法会阻塞直到服务停止。
func (rm *ResourceManager) Start() error {
	// 实现...
}
```

### 测试规范

#### 1. 单元测试

```go
// resourcemanager_test.go
func TestResourceManager_NewResourceManager(t *testing.T) {
    tests := []struct {
        name    string
        config  *Config
        want    *ResourceManager
        wantErr bool
    }{
        {
            name:   "valid config",
            config: &Config{Port: 8088},
            want:   &ResourceManager{},
            wantErr: false,
        },
        {
            name:    "nil config",
            config:  nil,
            want:    nil,
            wantErr: true,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got, err := NewResourceManager(tt.config)
            if (err != nil) != tt.wantErr {
                t.Errorf("NewResourceManager() error = %v, wantErr %v", err, tt.wantErr)
                return
            }
            if !reflect.DeepEqual(got, tt.want) {
                t.Errorf("NewResourceManager() = %v, want %v", got, tt.want)
            }
        })
    }
}
```

#### 2. 基准测试

```go
func BenchmarkResourceManager_AllocateResource(b *testing.B) {
    rm := setupTestResourceManager()
    req := &ResourceRequest{
        Memory: 1024,
        VCores: 1,
    }

    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        rm.AllocateResource(req)
    }
}

func BenchmarkScheduler_Schedule(b *testing.B) {
    scheduler := NewFIFOScheduler()
    requests := make([]*ResourceRequest, 1000)
    for i := range requests {
        requests[i] = &ResourceRequest{Memory: 1024, VCores: 1}
    }

    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        scheduler.Schedule(requests)
    }
}
```

#### 3. 集成测试

```go
// integration_test.go
func TestIntegration_FullWorkflow(t *testing.T) {
    // 启动测试集群
    cluster := setupTestCluster(t)
    defer cluster.Cleanup()

    // 提交应用
    app := &Application{
        Name:   "test-app",
        Memory: 1024,
        VCores: 1,
    }

    appID, err := cluster.SubmitApplication(app)
    require.NoError(t, err)

    // 等待应用完成
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()

    err = cluster.WaitForApplicationCompletion(ctx, appID)
    require.NoError(t, err)

    // 验证结果
    status, err := cluster.GetApplicationStatus(appID)
    require.NoError(t, err)
    assert.Equal(t, ApplicationStateFinished, status.State)
}
```

## 🔧 调试技巧

### 1. 使用 Delve 调试器

```bash
# 调试 ResourceManager
dlv debug cmd/resourcemanager/main.go -- --config configs/resourcemanager.yaml

# 设置断点
(dlv) break internal/resourcemanager/resource_manager.go:100
(dlv) continue

# 查看变量
(dlv) print rm.applications
(dlv) locals

# 查看调用栈
(dlv) stack
```

### 2. 日志调试

```go
// 结构化日志
logger := zap.NewDevelopment()
defer logger.Sync()

logger.Info("processing request",
    zap.String("app_id", appID),
    zap.Int64("memory", req.Memory),
    zap.Int32("vcores", req.VCores),
    zap.Duration("duration", time.Since(start)),
)

// 条件日志
if logger.Core().Enabled(zap.DebugLevel) {
    logger.Debug("detailed state",
        zap.Any("state", rm.getDetailedState()),
    )
}
```

### 3. 性能调试

```go
// CPU 性能分析
import _ "net/http/pprof"

go func() {
    log.Println(http.ListenAndServe("localhost:6060", nil))
}()

// 在代码中添加性能标记
func (rm *ResourceManager) processRequests() {
    defer func(start time.Time) {
        processRequestsDuration.Observe(time.Since(start).Seconds())
    }(time.Now())

    // 处理逻辑
}
```

```bash
# 生成 CPU profile
go tool pprof http://localhost:6060/debug/pprof/profile?seconds=30

# 生成内存 profile
go tool pprof http://localhost:6060/debug/pprof/heap

# 查看 goroutine
go tool pprof http://localhost:6060/debug/pprof/goroutine
```

### 4. 集成测试调试

```go
func TestDebugMode(t *testing.T) {
    if !testing.Verbose() {
        t.Skip("skipping debug test in non-verbose mode")
    }

    // 启用详细日志
    config := zap.NewDevelopmentConfig()
    config.Level = zap.NewAtomicLevelAt(zap.DebugLevel)
    logger, _ := config.Build()

    // 测试逻辑
}
```

## 🚀 开发工作流

### 1. 分支管理

```bash
# 从 main 分支创建功能分支
git checkout main
git pull origin main
git checkout -b feature/scheduler-improvement

# 开发完成后
git add .
git commit -m "feat: improve capacity scheduler performance"
git push origin feature/scheduler-improvement

# 创建 Pull Request
gh pr create --title "Improve capacity scheduler performance" \
             --body "This PR improves the capacity scheduler by..."
```

### 2. 代码检查

```bash
# 运行所有检查
make check

# 或者分别运行
make fmt        # 格式化代码
make lint       # 代码检查
make test       # 运行测试
make test-race  # 竞态检测
make coverage   # 测试覆盖率
```

### 3. 热重载开发

```bash
# 使用 air 进行热重载
air -c .air.toml

# .air.toml 配置
[build]
cmd = "go build -o bin/resourcemanager cmd/resourcemanager/main.go"
bin = "bin/resourcemanager"
include_ext = ["go", "yaml"]
exclude_dir = ["bin", "vendor", ".git"]
```

### 4. 本地测试集群

```bash
# 启动本地集群
make dev-cluster

# 或者手动启动
make build
./scripts/start-dev-cluster.sh

# 运行集成测试
make test-integration

# 清理
make clean-dev
```

## 📊 性能优化

### 1. 内存优化

```go
// 对象池使用
var requestPool = sync.Pool{
    New: func() interface{} {
        return &ResourceRequest{}
    },
}

func (rm *ResourceManager) processRequest() {
    req := requestPool.Get().(*ResourceRequest)
    defer requestPool.Put(req)

    // 重置对象
    req.Reset()

    // 处理逻辑
}

// 避免内存泄露
type ResourceManager struct {
    // 使用 context 控制生命周期
    ctx    context.Context
    cancel context.CancelFunc
}

func (rm *ResourceManager) cleanup() {
    rm.cancel() // 取消所有子 goroutine
}
```

### 2. 并发优化

```go
// Worker Pool 模式
type WorkerPool struct {
    workers int
    jobs    chan Job
    results chan Result
}

func NewWorkerPool(workers int) *WorkerPool {
    return &WorkerPool{
        workers: workers,
        jobs:    make(chan Job, workers),
        results: make(chan Result, workers),
    }
}

func (wp *WorkerPool) Start() {
    for i := 0; i < wp.workers; i++ {
        go wp.worker()
    }
}

func (wp *WorkerPool) worker() {
    for job := range wp.jobs {
        result := job.Process()
        wp.results <- result
    }
}
```

### 3. 锁优化

```go
// 读写分离
type ResourceTracker struct {
    // 分离读写锁
    allocMu sync.RWMutex
    allocs  map[string]*Allocation

    metricsMu sync.RWMutex
    metrics   *Metrics
}

// 细粒度锁
type NodeManager struct {
    nodesMu sync.RWMutex
    nodes   map[string]*Node

    // 每个节点独立的锁
    nodeLocks map[string]*sync.RWMutex
}
```

## 🧪 测试最佳实践

### 1. 测试组织

```go
// 测试套件
type ResourceManagerTestSuite struct {
    suite.Suite
    rm     *ResourceManager
    config *Config
}

func (suite *ResourceManagerTestSuite) SetupTest() {
    suite.config = &Config{Port: 8088}
    suite.rm = NewResourceManager(suite.config)
}

func (suite *ResourceManagerTestSuite) TearDownTest() {
    suite.rm.Stop()
}

func (suite *ResourceManagerTestSuite) TestAllocateResource() {
    // 测试逻辑
}

func TestResourceManagerSuite(t *testing.T) {
    suite.Run(t, new(ResourceManagerTestSuite))
}
```

### 2. Mock 和 Stub

```go
//go:generate mockgen -source=scheduler.go -destination=mocks/mock_scheduler.go

type MockScheduler struct {
    ctrl *gomock.Controller
}

func TestResourceManager_WithMockScheduler(t *testing.T) {
    ctrl := gomock.NewController(t)
    defer ctrl.Finish()

    mockScheduler := NewMockScheduler(ctrl)
    mockScheduler.EXPECT().
        Schedule(gomock.Any()).
        Return([]*Allocation{}).
        Times(1)

    rm := &ResourceManager{scheduler: mockScheduler}
    // 测试逻辑
}
```

### 3. 测试数据管理

```go
// testdata/fixtures.go
func CreateTestApplication() *Application {
    return &Application{
        ID:     ApplicationID{ClusterTimestamp: 1000, ID: 1},
        Name:   "test-app",
        User:   "testuser",
        Queue:  "default",
        State:  ApplicationStateNew,
    }
}

func CreateTestNodes(count int) []*Node {
    nodes := make([]*Node, count)
    for i := range nodes {
        nodes[i] = &Node{
            ID:       NodeID{Host: fmt.Sprintf("node%d", i), Port: 8042},
            Resource: Resource{Memory: 4096, VCores: 4},
            State:    NodeStateRunning,
        }
    }
    return nodes
}
```

## 📚 相关资源

### 开发工具

- [Go 官方工具](https://golang.org/cmd/)
- [golangci-lint](https://golangci-lint.run/)
- [Delve 调试器](https://github.com/go-delve/delve)
- [air 热重载](https://github.com/cosmtrek/air)

### 学习资源

- [Effective Go](https://golang.org/doc/effective_go.html)
- [Go Code Review Comments](https://go.dev/wiki/CodeReviewComments)
- [Uber Go Style Guide](https://github.com/uber-go/guide/blob/master/style.md)

### 相关文档

- [调试指南](./调试指南.md) - 详细的调试方法
- [测试指南](./测试指南.md) - 测试策略和实践
- [贡献指南](./贡献指南.md) - 如何为项目贡献代码
