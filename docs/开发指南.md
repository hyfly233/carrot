# Carrot YARN å¼€å‘æŒ‡å—

æœ¬æŒ‡å—ä¸º Carrot é¡¹ç›®çš„å¼€å‘è€…æä¾›å®Œæ•´çš„å¼€å‘ç¯å¢ƒæ­å»ºã€ä»£ç è§„èŒƒã€æµ‹è¯•å’Œè°ƒè¯•æ–¹æ³•ã€‚

## ğŸ› ï¸ å¼€å‘ç¯å¢ƒæ­å»º

### åŸºç¡€è¦æ±‚

```bash
# Go ç‰ˆæœ¬è¦æ±‚
go version  # éœ€è¦ Go 1.24+

# å¿…éœ€çš„å·¥å…·
go install golang.org/x/tools/cmd/goimports@latest
go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest
go install github.com/go-delve/delve/cmd/dlv@latest

# å¯é€‰å·¥å…· (æ¨è)
go install github.com/air-verse/air@latest  # çƒ­é‡è½½
go install github.com/swaggo/swag/cmd/swag@latest  # API æ–‡æ¡£ç”Ÿæˆ
```

### IDE é…ç½®

#### VS Code é…ç½®

åˆ›å»º `.vscode/launch.json`:

```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Debug ResourceManager",
      "type": "go",
      "request": "launch",
      "mode": "auto",
      "program": "${workspaceFolder}/cmd/resourcemanager/main.go",
      "args": [
        "--config",
        "${workspaceFolder}/configs/resourcemanager.yaml",
        "--log-level",
        "debug"
      ],
      "env": {
        "CARROT_DEBUG": "true"
      },
      "console": "integratedTerminal"
    },
    {
      "name": "Debug NodeManager",
      "type": "go",
      "request": "launch",
      "mode": "auto",
      "program": "${workspaceFolder}/cmd/rmnm/main.go",
      "args": [
        "--config",
        "${workspaceFolder}/configs/rmnm.yaml",
        "--rm-url",
        "http://localhost:8088"
      ],
      "env": {
        "CARROT_DEBUG": "true"
      },
      "console": "integratedTerminal"
    },
    {
      "name": "Debug ApplicationMaster",
      "type": "go",
      "request": "launch",
      "mode": "auto",
      "program": "${workspaceFolder}/cmd/applicationmaster/main.go",
      "args": [
        "--rm-url",
        "http://localhost:8088",
        "--app-name",
        "test-app"
      ],
      "console": "integratedTerminal"
    },
    {
      "name": "Debug Test",
      "type": "go",
      "request": "launch",
      "mode": "test",
      "program": "${workspaceFolder}",
      "args": [
        "-test.v"
      ]
    }
  ]
}
```

åˆ›å»º `.vscode/settings.json`:

```json
{
    "go.useLanguageServer": true,
    "go.formatTool": "goimports",
    "go.lintTool": "golangci-lint",
    "go.testFlags": ["-v"],
    "go.testTimeout": "30s",
    "go.coverOnSave": true,
    "go.coverageDecorator": {
        "type": "gutter",
        "coveredHighlightColor": "rgba(64,128,128,0.5)",
        "uncoveredHighlightColor": "rgba(128,64,64,0.25)",
        "coveredGutterStyle": "blockblue",
        "uncoveredGutterStyle": "blockred"
    },
    "files.exclude": {
        "**/.git": true,
        "**/bin": true,
        "**/vendor": true
    }
}
```

#### GoLand/IntelliJ é…ç½®

```xml
<!-- .idea/runConfigurations/ResourceManager.xml -->
<component name="ProjectRunConfigurationManager">
    <configuration default="false" name="ResourceManager" type="GoApplicationRunConfiguration"
                   factoryName="Go Application">
        <module name="carrot"/>
        <working_directory value="$PROJECT_DIR$"/>
        <kind value="FILE"/>
        <filePath value="$PROJECT_DIR$/cmd/resourcemanager/main.go"/>
        <parameters value="--config configs/resourcemanager.yaml --log-level debug"/>
        <envs>
            <env name="CARROT_DEBUG" value="true"/>
        </envs>
        <method v="2"/>
    </configuration>
</component>
```

### é¡¹ç›®ç»“æ„

```
carrot/
â”œâ”€â”€ cmd/                    # ä¸»ç¨‹åºå…¥å£
â”‚   â”œâ”€â”€ resourcemanager/
â”‚   â”œâ”€â”€ nodemanager/
â”‚   â”œâ”€â”€ applicationmaster/
â”‚   â””â”€â”€ client/
â”œâ”€â”€ internal/               # å†…éƒ¨åŒ…
â”‚   â”œâ”€â”€ common/            # å…¬å…±ä»£ç 
â”‚   â”œâ”€â”€ resourcemanager/   # RM å®ç°
â”‚   â”œâ”€â”€ nodemanager/       # NM å®ç°
â”‚   â””â”€â”€ applicationmaster/ # AM å®ç°
â”œâ”€â”€ configs/               # é…ç½®æ–‡ä»¶
â”œâ”€â”€ deployments/           # éƒ¨ç½²é…ç½®
â”‚   â”œâ”€â”€ docker/
â”‚   â””â”€â”€ k8s/
â”œâ”€â”€ docs/                  # æ–‡æ¡£
â”œâ”€â”€ scripts/               # è„šæœ¬
â”œâ”€â”€ tests/                 # æµ‹è¯•
â”‚   â”œâ”€â”€ integration/
â”‚   â””â”€â”€ e2e/
â”œâ”€â”€ tools/                 # å·¥å…·
â”œâ”€â”€ .github/               # GitHub é…ç½®
â”œâ”€â”€ Makefile
â”œâ”€â”€ go.mod
â””â”€â”€ go.sum
```

## ğŸ“‹ ä»£ç è§„èŒƒ

### Go ç¼–ç è§„èŒƒ

#### 1. åŒ…å‘½å

```go
// âœ… å¥½çš„åŒ…å
package resourcemanager
package scheduler
package common

// âŒ é¿å…çš„åŒ…å
package rm_server
package ResourceManager
package utils
```

#### 2. æ¥å£è®¾è®¡

```go
// âœ… æ¥å£åä»¥ -er ç»“å°¾
type Scheduler interface {
    Schedule(requests []*ResourceRequest) []*Allocation
}

type ResourceTracker interface {
    AllocateResource(containerID ContainerID, resource Resource) error
    ReleaseResource(containerID ContainerID) error
}

// âœ… å°æ¥å£åŸåˆ™
type Reader interface {
    Read([]byte) (int, error)
}

type Writer interface {
    Write([]byte) (int, error)
}

// âŒ é¿å…å¤§æ¥å£
type HugeInterface interface {
    Method1()
    Method2()
    // ... 10+ methods
}
```

#### 3. é”™è¯¯å¤„ç†

```go
// âœ… è‡ªå®šä¹‰é”™è¯¯ç±»å‹
type InsufficientResourceError struct {
    Requested Resource
    Available Resource
}

func (e *InsufficientResourceError) Error() string {
    return fmt.Sprintf("insufficient resources: requested %v, available %v",
        e.Requested, e.Available)
}

// âœ… é”™è¯¯åŒ…è£…
func (rm *ResourceManager) AllocateResource(req *ResourceRequest) error {
    if err := rm.validateRequest(req); err != nil {
        return fmt.Errorf("failed to validate request: %w", err)
    }

    if err := rm.scheduler.Allocate(req); err != nil {
        return fmt.Errorf("scheduler allocation failed: %w", err)
    }

    return nil
}

// âœ… å“¨å…µé”™è¯¯
var (
    ErrApplicationNotFound = errors.New("åº”ç”¨æœªæ‰¾åˆ°")
    ErrNodeOffline         = errors.New("node is offline")
)
```

#### 4. ç»“æ„ä½“è®¾è®¡

```go
// âœ… å­—æ®µåˆ†ç»„å’Œæ³¨é‡Š
type ResourceManager struct {
    // æ ¸å¿ƒç»„ä»¶
    applicationManager *applicationmanager.ApplicationManager
    nodeManager        *nodemanager.NodeManager
    scheduler          scheduler.Scheduler

    // é…ç½®å’ŒçŠ¶æ€
    config *Config
    state  *State

    // åŒæ­¥åŸè¯­
    mu     sync.RWMutex

    // é€šé“å’Œæ§åˆ¶
    stopCh chan struct{}
    doneCh chan struct{}

    // æ—¥å¿—å’Œç›‘æ§
    logger  *zap.Logger
    metrics *Metrics
}

// âœ… æ„é€ å‡½æ•°æ¨¡å¼
func NewResourceManager(config *Config) *ResourceManager {
    rm := &ResourceManager{
        config: config,
        stopCh: make(chan struct{}),
        doneCh: make(chan struct{}),
        logger: zap.NewNop(),
    }

    // åˆå§‹åŒ–ç»„ä»¶
    rm.applicationManager = applicationmanager.New(config.ApplicationManager)
    rm.nodeManager = nodemanager.New(config.NodeManager)

    return rm
}
```

#### 5. å¹¶å‘å®‰å…¨

```go
// âœ… è¯»å†™é”ä½¿ç”¨
type SafeCounter struct {
    mu    sync.RWMutex
    value int64
}

func (c *SafeCounter) Get() int64 {
    c.mu.RLock()
    defer c.mu.RUnlock()
    return c.value
}

func (c *SafeCounter) Inc() {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.value++
}

// âœ… Context ä¼ é€’
func (rm *ResourceManager) ProcessRequest(ctx context.Context, req *Request) error {
    select {
    case <-ctx.Done():
        return ctx.Err()
    default:
        return rm.doProcess(ctx, req)
    }
}
```

### æ³¨é‡Šè§„èŒƒ

```go
// Package resourcemanager å®ç° YARN ResourceManager çš„æ ¸å¿ƒåŠŸèƒ½ã€‚
//
// ResourceManager è´Ÿè´£ç®¡ç†é›†ç¾¤èµ„æºï¼Œè°ƒåº¦åº”ç”¨ç¨‹åºï¼Œ
// ä»¥åŠç›‘æ§ NodeManager çš„çŠ¶æ€ã€‚ä¸»è¦ç»„ä»¶åŒ…æ‹¬ï¼š
//   - ApplicationManager: ç®¡ç†åº”ç”¨ç¨‹åºç”Ÿå‘½å‘¨æœŸ
//   - NodeManager: ç®¡ç†èŠ‚ç‚¹æ³¨å†Œå’Œå¿ƒè·³
//   - Scheduler: å®ç°èµ„æºè°ƒåº¦ç®—æ³•
//
// ä½¿ç”¨ç¤ºä¾‹ï¼š
//   config := &Config{Port: 8088}
//   rm := NewResourceManager(config)
//   if err := rm.Start(); err != nil {
//       log.Fatal(err)
//   }
package resourcemanager

// ResourceManager è¡¨ç¤º YARN èµ„æºç®¡ç†å™¨çš„ä¸»è¦å®ç°ã€‚
//
// å®ƒåè°ƒé›†ç¾¤ä¸­çš„æ‰€æœ‰èµ„æºåˆ†é…å’Œåº”ç”¨ç¨‹åºè°ƒåº¦ã€‚
// ResourceManager æ˜¯æ— çŠ¶æ€çš„ï¼Œæ”¯æŒé«˜å¯ç”¨éƒ¨ç½²ã€‚
type ResourceManager struct {
	// ç§æœ‰å­—æ®µä¸éœ€è¦æ³¨é‡Šï¼Œé™¤éæœ‰ç‰¹æ®Šè¯´æ˜
}

// NewResourceManager åˆ›å»ºä¸€ä¸ªæ–°çš„ ResourceManager å®ä¾‹ã€‚
//
// å‚æ•°:
//   config - ResourceManager é…ç½®ï¼Œä¸èƒ½ä¸º nil
//
// è¿”å›:
//   *ResourceManager - æ–°åˆ›å»ºçš„å®ä¾‹
//
// å¦‚æœé…ç½®æ— æ•ˆï¼Œæ­¤å‡½æ•°ä¼š panicã€‚
func NewResourceManager(config *Config) *ResourceManager {
	// å®ç°...
}

// Start å¯åŠ¨ ResourceManager æœåŠ¡ã€‚
//
// è¿™ä¸ªæ–¹æ³•ä¼šï¼š
//   1. åˆå§‹åŒ–æ‰€æœ‰å­ç»„ä»¶
//   2. å¯åŠ¨ HTTP æœåŠ¡å™¨
//   3. å¼€å§‹å¤„ç†å¿ƒè·³å’Œè¯·æ±‚
//
// è¿”å›çš„ error è¡¨ç¤ºå¯åŠ¨è¿‡ç¨‹ä¸­çš„ä»»ä½•å¤±è´¥ã€‚
// å¦‚æœå¯åŠ¨æˆåŠŸï¼Œè¯¥æ–¹æ³•ä¼šé˜»å¡ç›´åˆ°æœåŠ¡åœæ­¢ã€‚
func (rm *ResourceManager) Start() error {
	// å®ç°...
}
```

### æµ‹è¯•è§„èŒƒ

#### 1. å•å…ƒæµ‹è¯•

```go
// resourcemanager_test.go
func TestResourceManager_NewResourceManager(t *testing.T) {
    tests := []struct {
        name    string
        config  *Config
        want    *ResourceManager
        wantErr bool
    }{
        {
            name:   "valid config",
            config: &Config{Port: 8088},
            want:   &ResourceManager{},
            wantErr: false,
        },
        {
            name:    "nil config",
            config:  nil,
            want:    nil,
            wantErr: true,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got, err := NewResourceManager(tt.config)
            if (err != nil) != tt.wantErr {
                t.Errorf("NewResourceManager() error = %v, wantErr %v", err, tt.wantErr)
                return
            }
            if !reflect.DeepEqual(got, tt.want) {
                t.Errorf("NewResourceManager() = %v, want %v", got, tt.want)
            }
        })
    }
}
```

#### 2. åŸºå‡†æµ‹è¯•

```go
func BenchmarkResourceManager_AllocateResource(b *testing.B) {
    rm := setupTestResourceManager()
    req := &ResourceRequest{
        Memory: 1024,
        VCores: 1,
    }

    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        rm.AllocateResource(req)
    }
}

func BenchmarkScheduler_Schedule(b *testing.B) {
    scheduler := NewFIFOScheduler()
    requests := make([]*ResourceRequest, 1000)
    for i := range requests {
        requests[i] = &ResourceRequest{Memory: 1024, VCores: 1}
    }

    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        scheduler.Schedule(requests)
    }
}
```

#### 3. é›†æˆæµ‹è¯•

```go
// integration_test.go
func TestIntegration_FullWorkflow(t *testing.T) {
    // å¯åŠ¨æµ‹è¯•é›†ç¾¤
    cluster := setupTestCluster(t)
    defer cluster.Cleanup()

    // æäº¤åº”ç”¨
    app := &Application{
        Name:   "test-app",
        Memory: 1024,
        VCores: 1,
    }

    appID, err := cluster.SubmitApplication(app)
    require.NoError(t, err)

    // ç­‰å¾…åº”ç”¨å®Œæˆ
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()

    err = cluster.WaitForApplicationCompletion(ctx, appID)
    require.NoError(t, err)

    // éªŒè¯ç»“æœ
    status, err := cluster.GetApplicationStatus(appID)
    require.NoError(t, err)
    assert.Equal(t, ApplicationStateFinished, status.State)
}
```

## ğŸ”§ è°ƒè¯•æŠ€å·§

### 1. ä½¿ç”¨ Delve è°ƒè¯•å™¨

```bash
# è°ƒè¯• ResourceManager
dlv debug cmd/resourcemanager/main.go -- --config configs/resourcemanager.yaml

# è®¾ç½®æ–­ç‚¹
(dlv) break internal/resourcemanager/resource_manager.go:100
(dlv) continue

# æŸ¥çœ‹å˜é‡
(dlv) print rm.applications
(dlv) locals

# æŸ¥çœ‹è°ƒç”¨æ ˆ
(dlv) stack
```

### 2. æ—¥å¿—è°ƒè¯•

```go
// ç»“æ„åŒ–æ—¥å¿—
logger := zap.NewDevelopment()
defer logger.Sync()

logger.Info("processing request",
    zap.String("app_id", appID),
    zap.Int64("memory", req.Memory),
    zap.Int32("vcores", req.VCores),
    zap.Duration("duration", time.Since(start)),
)

// æ¡ä»¶æ—¥å¿—
if logger.Core().Enabled(zap.DebugLevel) {
    logger.Debug("detailed state",
        zap.Any("state", rm.getDetailedState()),
    )
}
```

### 3. æ€§èƒ½è°ƒè¯•

```go
// CPU æ€§èƒ½åˆ†æ
import _ "net/http/pprof"

go func() {
    log.Println(http.ListenAndServe("localhost:6060", nil))
}()

// åœ¨ä»£ç ä¸­æ·»åŠ æ€§èƒ½æ ‡è®°
func (rm *ResourceManager) processRequests() {
    defer func(start time.Time) {
        processRequestsDuration.Observe(time.Since(start).Seconds())
    }(time.Now())

    // å¤„ç†é€»è¾‘
}
```

```bash
# ç”Ÿæˆ CPU profile
go tool pprof http://localhost:6060/debug/pprof/profile?seconds=30

# ç”Ÿæˆå†…å­˜ profile
go tool pprof http://localhost:6060/debug/pprof/heap

# æŸ¥çœ‹ goroutine
go tool pprof http://localhost:6060/debug/pprof/goroutine
```

### 4. é›†æˆæµ‹è¯•è°ƒè¯•

```go
func TestDebugMode(t *testing.T) {
    if !testing.Verbose() {
        t.Skip("skipping debug test in non-verbose mode")
    }

    // å¯ç”¨è¯¦ç»†æ—¥å¿—
    config := zap.NewDevelopmentConfig()
    config.Level = zap.NewAtomicLevelAt(zap.DebugLevel)
    logger, _ := config.Build()

    // æµ‹è¯•é€»è¾‘
}
```

## ğŸš€ å¼€å‘å·¥ä½œæµ

### 1. åˆ†æ”¯ç®¡ç†

```bash
# ä» main åˆ†æ”¯åˆ›å»ºåŠŸèƒ½åˆ†æ”¯
git checkout main
git pull origin main
git checkout -b feature/scheduler-improvement

# å¼€å‘å®Œæˆå
git add .
git commit -m "feat: improve capacity scheduler performance"
git push origin feature/scheduler-improvement

# åˆ›å»º Pull Request
gh pr create --title "Improve capacity scheduler performance" \
             --body "This PR improves the capacity scheduler by..."
```

### 2. ä»£ç æ£€æŸ¥

```bash
# è¿è¡Œæ‰€æœ‰æ£€æŸ¥
make check

# æˆ–è€…åˆ†åˆ«è¿è¡Œ
make fmt        # æ ¼å¼åŒ–ä»£ç 
make lint       # ä»£ç æ£€æŸ¥
make test       # è¿è¡Œæµ‹è¯•
make test-race  # ç«æ€æ£€æµ‹
make coverage   # æµ‹è¯•è¦†ç›–ç‡
```

### 3. çƒ­é‡è½½å¼€å‘

```bash
# ä½¿ç”¨ air è¿›è¡Œçƒ­é‡è½½
air -c .air.toml

# .air.toml é…ç½®
[build]
cmd = "go build -o bin/resourcemanager cmd/resourcemanager/main.go"
bin = "bin/resourcemanager"
include_ext = ["go", "yaml"]
exclude_dir = ["bin", "vendor", ".git"]
```

### 4. æœ¬åœ°æµ‹è¯•é›†ç¾¤

```bash
# å¯åŠ¨æœ¬åœ°é›†ç¾¤
make dev-cluster

# æˆ–è€…æ‰‹åŠ¨å¯åŠ¨
make build
./scripts/start-dev-cluster.sh

# è¿è¡Œé›†æˆæµ‹è¯•
make test-integration

# æ¸…ç†
make clean-dev
```

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–

### 1. å†…å­˜ä¼˜åŒ–

```go
// å¯¹è±¡æ± ä½¿ç”¨
var requestPool = sync.Pool{
    New: func() interface{} {
        return &ResourceRequest{}
    },
}

func (rm *ResourceManager) processRequest() {
    req := requestPool.Get().(*ResourceRequest)
    defer requestPool.Put(req)

    // é‡ç½®å¯¹è±¡
    req.Reset()

    // å¤„ç†é€»è¾‘
}

// é¿å…å†…å­˜æ³„éœ²
type ResourceManager struct {
    // ä½¿ç”¨ context æ§åˆ¶ç”Ÿå‘½å‘¨æœŸ
    ctx    context.Context
    cancel context.CancelFunc
}

func (rm *ResourceManager) cleanup() {
    rm.cancel() // å–æ¶ˆæ‰€æœ‰å­ goroutine
}
```

### 2. å¹¶å‘ä¼˜åŒ–

```go
// Worker Pool æ¨¡å¼
type WorkerPool struct {
    workers int
    jobs    chan Job
    results chan Result
}

func NewWorkerPool(workers int) *WorkerPool {
    return &WorkerPool{
        workers: workers,
        jobs:    make(chan Job, workers),
        results: make(chan Result, workers),
    }
}

func (wp *WorkerPool) Start() {
    for i := 0; i < wp.workers; i++ {
        go wp.worker()
    }
}

func (wp *WorkerPool) worker() {
    for job := range wp.jobs {
        result := job.Process()
        wp.results <- result
    }
}
```

### 3. é”ä¼˜åŒ–

```go
// è¯»å†™åˆ†ç¦»
type ResourceTracker struct {
    // åˆ†ç¦»è¯»å†™é”
    allocMu sync.RWMutex
    allocs  map[string]*Allocation

    metricsMu sync.RWMutex
    metrics   *Metrics
}

// ç»†ç²’åº¦é”
type NodeManager struct {
    nodesMu sync.RWMutex
    nodes   map[string]*Node

    // æ¯ä¸ªèŠ‚ç‚¹ç‹¬ç«‹çš„é”
    nodeLocks map[string]*sync.RWMutex
}
```

## ğŸ§ª æµ‹è¯•æœ€ä½³å®è·µ

### 1. æµ‹è¯•ç»„ç»‡

```go
// æµ‹è¯•å¥—ä»¶
type ResourceManagerTestSuite struct {
    suite.Suite
    rm     *ResourceManager
    config *Config
}

func (suite *ResourceManagerTestSuite) SetupTest() {
    suite.config = &Config{Port: 8088}
    suite.rm = NewResourceManager(suite.config)
}

func (suite *ResourceManagerTestSuite) TearDownTest() {
    suite.rm.Stop()
}

func (suite *ResourceManagerTestSuite) TestAllocateResource() {
    // æµ‹è¯•é€»è¾‘
}

func TestResourceManagerSuite(t *testing.T) {
    suite.Run(t, new(ResourceManagerTestSuite))
}
```

### 2. Mock å’Œ Stub

```go
//go:generate mockgen -source=scheduler.go -destination=mocks/mock_scheduler.go

type MockScheduler struct {
    ctrl *gomock.Controller
}

func TestResourceManager_WithMockScheduler(t *testing.T) {
    ctrl := gomock.NewController(t)
    defer ctrl.Finish()

    mockScheduler := NewMockScheduler(ctrl)
    mockScheduler.EXPECT().
        Schedule(gomock.Any()).
        Return([]*Allocation{}).
        Times(1)

    rm := &ResourceManager{scheduler: mockScheduler}
    // æµ‹è¯•é€»è¾‘
}
```

### 3. æµ‹è¯•æ•°æ®ç®¡ç†

```go
// testdata/fixtures.go
func CreateTestApplication() *Application {
    return &Application{
        ID:     ApplicationID{ClusterTimestamp: 1000, ID: 1},
        Name:   "test-app",
        User:   "testuser",
        Queue:  "default",
        State:  ApplicationStateNew,
    }
}

func CreateTestNodes(count int) []*Node {
    nodes := make([]*Node, count)
    for i := range nodes {
        nodes[i] = &Node{
            ID:       NodeID{Host: fmt.Sprintf("node%d", i), Port: 8042},
            Resource: Resource{Memory: 4096, VCores: 4},
            State:    NodeStateRunning,
        }
    }
    return nodes
}
```

## ğŸ“š ç›¸å…³èµ„æº

### å¼€å‘å·¥å…·

- [Go å®˜æ–¹å·¥å…·](https://golang.org/cmd/)
- [golangci-lint](https://golangci-lint.run/)
- [Delve è°ƒè¯•å™¨](https://github.com/go-delve/delve)
- [air çƒ­é‡è½½](https://github.com/cosmtrek/air)

### å­¦ä¹ èµ„æº

- [Effective Go](https://golang.org/doc/effective_go.html)
- [Go Code Review Comments](https://go.dev/wiki/CodeReviewComments)
- [Uber Go Style Guide](https://github.com/uber-go/guide/blob/master/style.md)

### ç›¸å…³æ–‡æ¡£

- [è°ƒè¯•æŒ‡å—](./è°ƒè¯•æŒ‡å—.md) - è¯¦ç»†çš„è°ƒè¯•æ–¹æ³•
- [æµ‹è¯•æŒ‡å—](./æµ‹è¯•æŒ‡å—.md) - æµ‹è¯•ç­–ç•¥å’Œå®è·µ
- [è´¡çŒ®æŒ‡å—](./è´¡çŒ®æŒ‡å—.md) - å¦‚ä½•ä¸ºé¡¹ç›®è´¡çŒ®ä»£ç 
